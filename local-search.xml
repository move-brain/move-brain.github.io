<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>一个好玩的签到打印</title>
    <link href="/super_zhu/2022/11/26/%E4%B8%80%E4%B8%AA%E5%A5%BD%E7%8E%A9%E7%9A%84%E7%AD%BE%E5%88%B0%E6%89%93%E5%8D%B0/"/>
    <url>/super_zhu/2022/11/26/%E4%B8%80%E4%B8%AA%E5%A5%BD%E7%8E%A9%E7%9A%84%E7%AD%BE%E5%88%B0%E6%89%93%E5%8D%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="一个好玩的签到打印"><a href="#一个好玩的签到打印" class="headerlink" title="一个好玩的签到打印"></a>一个好玩的签到打印</h1><p>想要实现一个指令实现签到签退并且以一种好玩的形式打印，比如</p><p><img src="https://s2.loli.net/2022/11/26/SREd9y7WCOchK18.png" alt="image.png"></p><p>只需要以下几步：</p><ol><li>学习bash脚本语言，并且学会使用curl，cut，awk，|(管道符)的使用</li><li>配合相关软件，实现有趣的打印，这里的打印软件我使用的是cowsay和使打印渐变色的软件lolcat</li><li>设置快捷命令（按自己需求设置）</li></ol><blockquote><p>这个博客有一些好玩的打印软件的介绍<a href="https://blog.csdn.net/qq_38410494/article/details/119068145">(167条消息) 有趣的 Linux 命令行软件_zacharyzlj的博客-CSDN博客</a></p></blockquote><h2 id="开始编写"><a href="#开始编写" class="headerlink" title="开始编写"></a>开始编写</h2><p><strong>先说bash语言是什么</strong></p><p><strong>用我的话来说：bash就是一个shell程序，bash语言可以按你定好的逻辑自动对系统进行操作</strong></p><p>话不多说，直接上操作</p><p>先去测试的目录内，新建bash文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">touch test.sh<br></code></pre></td></tr></table></figure><p>然后再使用编辑器打开它，它的第一行一般都是</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br></code></pre></td></tr></table></figure><p>其中#！的意思是表明文件类型，&#x2F;bin&#x2F;bash表示bash程序，那这一行表示他是一个bash程序的文件</p><p>然后再学习相应知识，开始编写程序就好</p><p>以下是我的签退程序</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br>msg=$(curl -s -d <span class="hljs-string">&#x27;&#123;&quot;userId&quot;: &quot;2100301838&quot;&#125;&#x27;</span> -H <span class="hljs-string">&quot;Content-Type:application/json&quot;</span> https://at.kexie.space/api/user/signOut)<br><span class="hljs-comment">#使用msg接收返回的数据</span><br>results=$(<span class="hljs-built_in">echo</span> <span class="hljs-variable">$msg</span> | awk <span class="hljs-string">&#x27;BEGIN&#123;FS=&quot;code&quot;&#125;END&#123;print $2&#125;&#x27;</span>| awk <span class="hljs-string">&#x27;BEGIN&#123;FS=&quot;,&quot;&#125;END&#123;print $1&#125;&#x27;</span>| awk <span class="hljs-string">&#x27;BEGIN&#123;FS=&quot;:&quot;&#125;END&#123;print $2&#125;&#x27;</span>)<br><span class="hljs-comment">#对返回的code进行截取到results，以此判断是否签退成功</span><br><span class="hljs-comment">#以下是定义一个签退成功的函数out_su()</span><br><span class="hljs-function"><span class="hljs-title">out_su</span></span>()&#123;<br><span class="hljs-comment">#截取签到总时间</span><br>        totaltime=$(<span class="hljs-built_in">echo</span> <span class="hljs-variable">$msg</span> | awk <span class="hljs-string">&#x27;BEGIN&#123;FS=&quot;totalTime&quot;&#125;END&#123;print $2&#125;&#x27;</span> | awk <span class="hljs-string">&#x27;BEGIN&#123;FS=&quot;,&quot;&#125;END&#123;print $1&#125;&#x27;</span> | awk <span class="hljs-string">&#x27;BEGIN&#123;FS=&quot;\&quot;&quot;&#125;END&#123;print $3&#125;&#x27;</span>)<br><span class="hljs-comment">#截取本次签到时间</span><br>        accumulatedTime=$(<span class="hljs-built_in">echo</span> <span class="hljs-variable">$msg</span> | awk <span class="hljs-string">&#x27;BEGIN&#123;FS=&quot;accumulatedTime&quot;&#125;END&#123;print $2&#125;&#x27;</span> | awk <span class="hljs-string">&#x27;BEGIN&#123;FS=&quot;,&quot;&#125;END&#123;print $1&#125;&#x27;</span> | awk <span class="hljs-string">&#x27;BEGIN&#123;FS=&quot;\&quot;&quot;&#125;END&#123;print $3&#125;&#x27;</span>)<br><span class="hljs-comment">#执行以下打印命令</span><br>        cowsay -f dragon <span class="hljs-string">&quot;芜湖 本次摸鱼<span class="hljs-variable">$accumulatedTime</span>小时  本周共<span class="hljs-variable">$totaltime</span>小时&quot;</span> | lolcat<br>&#125;<br><span class="hljs-comment">#签退失败函数</span><br><span class="hljs-function"><span class="hljs-title">out_err</span></span>()&#123;<br>cowsay -f skeleton <span class="hljs-string">&quot;你小子不会忘记签到了吧&quot;</span> | lolcat<br>&#125;<br><span class="hljs-comment">#根据是否成功调用不同函数</span><br><span class="hljs-keyword">if</span> [ <span class="hljs-variable">$results</span> -eq <span class="hljs-string">&quot;0&quot;</span> ];<br><span class="hljs-keyword">then</span><br>        out_su<br><br><span class="hljs-keyword">else</span><br>        out_err<br><span class="hljs-keyword">fi</span><br><br></code></pre></td></tr></table></figure><p>以下是效果</p><p><img src="https://s2.loli.net/2022/11/26/SREd9y7WCOchK18.png" alt="image.png"></p><h2 id="配合其他软件打印"><a href="#配合其他软件打印" class="headerlink" title="配合其他软件打印"></a>配合其他软件打印</h2><p>其实就用了lolcat和cowsay，这两个软件都很容易使用，可以对照上面注释使用，更详细可以浏览器搜索，没什么好说的</p><h2 id="设置快捷命令"><a href="#设置快捷命令" class="headerlink" title="设置快捷命令"></a>设置快捷命令</h2><p>因为当我们不在签到文件的目录时总是要敲长长的路径打开很不方便，所以我们可以设置快捷命令快速下班哈哈哈</p><p>其实很简单，只需要通过alias命令注册就好</p><p>比如我想进入用户Ubuntu的目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">alias</span> cdu=<span class="hljs-string">&#x27;cd /home/ubuntu&#x27;</span><br></code></pre></td></tr></table></figure><p>将上述设置写到home目录下的相应用户目录的.bashrc文件中（**~&#x2F;.bashrc**）的</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># some more ls aliases</span><br><span class="hljs-built_in">alias</span> ll=<span class="hljs-string">&#x27;ls -alF&#x27;</span><br><span class="hljs-built_in">alias</span> la=<span class="hljs-string">&#x27;ls -A&#x27;</span><br><span class="hljs-built_in">alias</span> l=<span class="hljs-string">&#x27;ls -CF&#x27;</span><br></code></pre></td></tr></table></figure><p>跟着写上去就好</p><p>然后再运行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">source ~/.bashrc<br></code></pre></td></tr></table></figure><p>就OK了</p>]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ubuntu</tag>
      
      <tag>瞎搞</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>kali虚拟机与物理机的IP关系</title>
    <link href="/super_zhu/2022/11/26/kali%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%92%8C%E7%89%A9%E7%90%86%E6%9C%BA%E7%9A%84ip%E5%85%B3%E7%B3%BB/"/>
    <url>/super_zhu/2022/11/26/kali%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%92%8C%E7%89%A9%E7%90%86%E6%9C%BA%E7%9A%84ip%E5%85%B3%E7%B3%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="kali虚拟机和物理机的ip关系"><a href="#kali虚拟机和物理机的ip关系" class="headerlink" title="kali虚拟机和物理机的ip关系"></a>kali虚拟机和物理机的ip关系</h1><h2 id="nat模式下"><a href="#nat模式下" class="headerlink" title="nat模式下"></a>nat模式下</h2><p>两者的ip地址</p><p><img src="https://s2.loli.net/2022/11/26/D82F1ZKboaNf3hG.png"></p><h2 id="桥接模式下"><a href="#桥接模式下" class="headerlink" title="桥接模式下"></a>桥接模式下</h2><p><img src="https://s2.loli.net/2022/11/26/CQFGVdsHn3PoyiM.png"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>NAT模式下，物理主机与kali虚拟主机的IP并不在同一网段下；桥接模式下，物理主机与kali虚拟主机IP同属于一个网段。</p>]]></content>
    
    
    <categories>
      
      <category>网络渗透测试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>渗透作业</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ubuntu部署-使用docker配置mysql</title>
    <link href="/super_zhu/2022/11/22/ubuntu%E9%83%A8%E7%BD%B2-docker-%E9%85%8D%E7%BD%AEmysql/"/>
    <url>/super_zhu/2022/11/22/ubuntu%E9%83%A8%E7%BD%B2-docker-%E9%85%8D%E7%BD%AEmysql/</url>
    
    <content type="html"><![CDATA[<h1 id="使用docker配置mysql"><a href="#使用docker配置mysql" class="headerlink" title="使用docker配置mysql"></a>使用docker配置mysql</h1><h2 id="安装mysql"><a href="#安装mysql" class="headerlink" title="安装mysql"></a>安装mysql</h2><p>如果本机本身就运行有mysql，请运行以下命令关闭服务、</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo service mysql stop<br></code></pre></td></tr></table></figure><p>不然可能会有端口映射失败的问题</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">sudo docker <span class="hljs-built_in">run</span> -itd --name mysqldb -p 3306:3306 -e <span class="hljs-attribute">MYSQL_ROOT_PASSWORD</span>=<span class="hljs-string">&quot;your password&quot;</span> mysql:latest<br></code></pre></td></tr></table></figure><ul><li>运行时得带上标签:latest不然会报错，具体是什么原因我也不清楚</li><li>-e表示设置环境变量得意思，MYSQL_ROOT_PASSWORD  在这里是为root用户设置密码</li><li>-p表示将容器端口映射到主机端口</li></ul><blockquote><p>想要了解docker run 命令更多可选项可来<a href="https://docs.docker.com/engine/reference/commandline/run/">码头工人运行|码头工人文档 (docker.com)</a></p></blockquote><h2 id="配置远程连接"><a href="#配置远程连接" class="headerlink" title="配置远程连接"></a>配置远程连接</h2><p>进入容器后，登录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mysql -u root -p<br></code></pre></td></tr></table></figure><p>再输入密码</p><p>再给远程主机配置一个账户用于连接</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE USER &#x27;用户名&#x27;@&#x27;IP地址或者域名&#x27;  IDENTIFIED BY &#x27;*password*&#x27;;---创建用户<br>GRANT ALL  ON *.*  TO &#x27;用户名&#x27;@&#x27;主机IP地址&#x27;  WITH GRANT OPTION;---赋予权限<br></code></pre></td></tr></table></figure><p>然后再进行相应连接即可</p>]]></content>
    
    
    <categories>
      
      <category>服务器部署</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ubuntu</tag>
      
      <tag>docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ubuntu部署-docker的简单使用</title>
    <link href="/super_zhu/2022/11/20/ubuntu%E9%83%A8%E7%BD%B2-docker/"/>
    <url>/super_zhu/2022/11/20/ubuntu%E9%83%A8%E7%BD%B2-docker/</url>
    
    <content type="html"><![CDATA[<h1 id="ubuntu部署-docker的简单使用"><a href="#ubuntu部署-docker的简单使用" class="headerlink" title="ubuntu部署-docker的简单使用"></a>ubuntu部署-docker的简单使用</h1><h2 id="下载与安装"><a href="#下载与安装" class="headerlink" title="下载与安装"></a>下载与安装</h2><p><strong>我这里使用的是手动安装</strong></p><h3 id="先卸载旧版本的dockers"><a href="#先卸载旧版本的dockers" class="headerlink" title="先卸载旧版本的dockers"></a>先卸载旧版本的dockers</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt-get remove docker docker-engine docker.io containerd runc<br></code></pre></td></tr></table></figure><h3 id="使用dockers仓库安装"><a href="#使用dockers仓库安装" class="headerlink" title="使用dockers仓库安装"></a>使用dockers仓库安装</h3><p>首次安装需要先在Ubuntu的源上添加dockers官方的源</p><h4 id="设置仓库（dockers源）"><a href="#设置仓库（dockers源）" class="headerlink" title="设置仓库（dockers源）"></a>设置仓库（dockers源）</h4><p>更新一下Ubuntu的apt的软件包索引</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt-get update<br></code></pre></td></tr></table></figure><p>安装apt依赖包，用于HTTPS获取仓库</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt-get install \<br>    apt-transport-https \<br>    ca-certificates \<br>    curl \<br>    gnupg-agent \<br>    software-properties-common<br></code></pre></td></tr></table></figure><p>添加 Docker 的官方 GPG 密钥：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo curl -fsSL https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu/gpg | sudo apt-key add -<br></code></pre></td></tr></table></figure><p>验证你是否拥有带有指纹的密钥</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"> sudo apt-key fingerprint 0EBFCD88<br>   <br>pub   rsa4096 2017-02-22 [SCEA]<br>      9DC8 5822 9FC7 DD38 854A  E2D8 8D81 803C 0EBF CD88<br>uid           [ unknown] Docker Release (CE deb) &lt;docker@docker.com&gt;<br>sub   rsa4096 2017-02-22 [S]<br></code></pre></td></tr></table></figure><p>使用以下指令在源那里加上仓库</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo add-apt-repository \<br>   &quot;deb [arch=amd64] https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu/ \<br><span class="hljs-meta prompt_">  $</span><span class="language-bash">(lsb_release -cs) \</span><br><span class="language-bash">  stable<span class="hljs-string">&quot;</span></span><br></code></pre></td></tr></table></figure><p>再更新apt索引</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt-get update<br></code></pre></td></tr></table></figure><p>直接安装最新版dockers</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt-get install docker-ce docker-ce-cli containerd.io<br></code></pre></td></tr></table></figure><h4 id="测试是否安装成功"><a href="#测试是否安装成功" class="headerlink" title="测试是否安装成功"></a>测试是否安装成功</h4><p>执行以下命令，打印以下信息则是成功</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo docker run hello-world<br><br>Unable to find image &#x27;hello-world:latest&#x27; locally<br>latest: Pulling from library/hello-world<br>1b930d010525: Pull complete                                                                                                                                  Digest: sha256:c3b4ada4687bbaa170745b3e4dd8ac3f194ca95b2d0518b417fb47e5879d9b5f<br>Status: Downloaded newer image for hello-world:latest<br><br><br>Hello from Docker!<br>This message shows that your installation appears to be working correctly.<br><br><br>To generate this message, Docker took the following steps:<br> 1. The Docker client contacted the Docker daemon.<br> 2. The Docker daemon pulled the &quot;hello-world&quot; image from the Docker Hub.<br>    (amd64)<br> 3. The Docker daemon created a new container from that image which runs the<br>    executable that produces the output you are currently reading.<br> 4. The Docker daemon streamed that output to the Docker client, which sent it<br>    to your terminal.<br><br><br>To try something more ambitious, you can run an Ubuntu container with:<br><span class="hljs-meta prompt_"> $ </span><span class="language-bash">docker run -it ubuntu bash</span><br><br><br>Share images, automate workflows, and more with a free Docker ID:<br> https://hub.docker.com/<br><br><br>For more examples and ideas, visit:<br> https://docs.docker.com/get-started/<br></code></pre></td></tr></table></figure><h3 id="其他安装方式"><a href="#其他安装方式" class="headerlink" title="其他安装方式"></a>其他安装方式</h3><p>需要其他安装方式则可前往<a href="https://www.runoob.com/docker/ubuntu-docker-install.html">Ubuntu Docker 安装 | 菜鸟教程 (runoob.com)</a></p><p>或者是自行查找</p><h2 id="对于docker的使用"><a href="#对于docker的使用" class="headerlink" title="对于docker的使用"></a>对于docker的使用</h2><p><strong>本文只做docker的基础操作介绍</strong></p><h3 id="镜像操作"><a href="#镜像操作" class="headerlink" title="镜像操作"></a>镜像操作</h3><p>我们都知道镜像是用来创建容器的那我们怎么样获取镜像和用镜像来生成容器和一些操作的那么接下来就是介绍一些关于镜像的一些操作</p><h4 id="获取镜像"><a href="#获取镜像" class="headerlink" title="获取镜像"></a>获取镜像</h4><p><strong>建议使用<code>docker pull</code></strong> <strong>的方式获取</strong></p><p>其命令格式</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo docker pull [OPTIONS] NAME[:TAG|@DIGEST]<br></code></pre></td></tr></table></figure><p>意思就是在docker源那里拉取相应的镜像</p><ul><li><p>name：就是要安装的镜像名字，若如果没有以下两个标签则是以<code>:latest</code>如<code>docker pull ubuntu</code>默认为<code>docker pull ubuntu:latest</code></p></li><li><p>tag：就是获取这个镜像相应版本的最新版，比如<code>sudo docker pull ubuntu:18.04</code>就是拉取系统版本为18.04的ubuntu镜像最新版</p></li><li><p>digest：表示是拉取指定版本的镜像系统，如 <code>sudo docker  pull ubuntu@sha256:45b23dee08af5e43a7fea6c4cf9c25ccf269ee113168c19722f87876677c5cb2</code></p></li></ul><h4 id="docker-run"><a href="#docker-run" class="headerlink" title="docker run"></a>docker run</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo docker run [OPTIONS] IMAGE [COMMAND] [ARG...]<br></code></pre></td></tr></table></figure><p>其实docker run 命令就是下载一个本地没有的镜像，并且创建一个容器</p><p>例如</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo docker run --rm  -it -d --gpus all --name test  ubuntu /bin/bash <br></code></pre></td></tr></table></figure><ul><li>以Ubuntu镜像创建一个名为test的容器</li><li>–rm 表示退出这个容器后自动移除这个容器</li><li>-d是指容器启动后以后台分离模式运行，默认会在前台模式运行，</li><li>-t和-i和&#x2F;bin&#x2F;bash,加起来表示使用bash创建一个伪终端，进入容器交互模式</li><li>gpus all 表示对于该容器，开启gpu支持，并且所有GPU都可用</li></ul><blockquote><p><a href="https://so.csdn.net/so/search?q=Docker&spm=1001.2101.3001.7020">Docker</a>容器后台运行,就必须有一个前台进程！</p><p>你如果执行sudo docker run -d –name test ubuntu ，虽然-d表示容器在后台挂起但事实上你会发现并不会在后台挂起，因为主线程任务已经执行完，而容器也自动关闭了</p><p>所以，sudo docker -itd –name test ubuntu 可以解决这个问题</p></blockquote><h4 id="查看镜像和容器"><a href="#查看镜像和容器" class="headerlink" title="查看镜像和容器"></a>查看镜像和容器</h4><p>查看镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo docker images<br><span class="hljs-meta prompt_">#</span><span class="language-bash">查看本机已有的镜像</span><br></code></pre></td></tr></table></figure><p>查看容器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo docker ps <br><span class="hljs-meta prompt_">#</span><span class="language-bash">查看正在运行的容器信息</span><br>sudo docker ps -a<br><span class="hljs-meta prompt_">#</span><span class="language-bash">查看全部容器信息</span><br></code></pre></td></tr></table></figure><h4 id="删除镜像"><a href="#删除镜像" class="headerlink" title="删除镜像"></a>删除镜像</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo docker rmi [OPTIONS] IMAGE [IMAGE...]<br></code></pre></td></tr></table></figure><p>支持删除多种镜像</p><ul><li>使用image id ：<code>sudo docker rmi fd484f19954f</code>    –这个image id可以直接<code>sudo docker images</code>查看镜像id</li><li>使用tag：<code>docker rmi test:latest</code></li><li>使用DIGEST： <code>docker rmi localhost:5000/test/busybox@sha256:cbbf2f9a99b47fc460d422812b6a5adff7dfee951d8fa2e4a98caa0382cfbdbf</code></li></ul><h3 id="容器操作"><a href="#容器操作" class="headerlink" title="容器操作"></a>容器操作</h3><p>容器就是以镜像为只读模板创建的</p><h4 id="创建容器"><a href="#创建容器" class="headerlink" title="创建容器"></a>创建容器</h4><p>前面已经说了可以以<code>docker run</code>来创建容器这里就不多说了</p><h4 id="进入容器交互"><a href="#进入容器交互" class="headerlink" title="进入容器交互"></a>进入容器交互</h4><p>要进入容器分两种情况</p><ul><li>进入已经后台分离模式下运行的容器内</li><li>已经关闭的容器内</li></ul><h5 id="后台分离模式下运行的容器"><a href="#后台分离模式下运行的容器" class="headerlink" title="后台分离模式下运行的容器"></a>后台分离模式下运行的容器</h5><p>对于已经启动的容器有两个命令进入 <code>attach</code> 和 <code>exec</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo docker exec -it test bash<br><span class="hljs-meta prompt_">#</span><span class="language-bash">进入一个名为<span class="hljs-built_in">test</span>的容器并打开伪终端</span><br>sudo docker attach  <br><span class="hljs-meta prompt_">#</span><span class="language-bash">attach不能使用-it bash</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">进入一个名为<span class="hljs-built_in">test</span>的容器并打开伪终端</span><br></code></pre></td></tr></table></figure><p>然后你在退出容器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">exit<br></code></pre></td></tr></table></figure><p>这个时候你会发现，当你以exec进入容器后退出容器并不会关闭而attach则相反</p><h5 id="关闭的容器"><a href="#关闭的容器" class="headerlink" title="关闭的容器"></a>关闭的容器</h5><p>关闭的容器当然是先启动再进入咯</p><p>重启容器的方式</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo docker restart 容器名或者容器id<br></code></pre></td></tr></table></figure><p>启动容器的方式</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo docker start 容器名或者容器id<br></code></pre></td></tr></table></figure><p><strong>不管是重启还是启动，容器都是以后台分离的模式运行</strong></p><p>然后再进入容器内即可</p><h4 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h4><p>都是基于<code>docker  rm</code>来进行</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs inform7">docker rm <span class="hljs-comment">[OPTIONS]</span> <span class="hljs-keyword">CONTAINER</span> <span class="hljs-comment">[CONTAINER...]</span><br></code></pre></td></tr></table></figure><p>例如删除ubuntu-test2这个容器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo docker rm ubuntu-test2<br></code></pre></td></tr></table></figure><h4 id="容器的停止和关闭和暂停"><a href="#容器的停止和关闭和暂停" class="headerlink" title="容器的停止和关闭和暂停"></a>容器的停止和关闭和暂停</h4><p>停止</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo docker stop test<br><span class="hljs-meta prompt_">#</span><span class="language-bash">也可以加入参数-t，表示在一定时间内无法关闭则强制关闭，默认时间为10s</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">比如sudo docker stop -t=20 <span class="hljs-built_in">test</span></span><br></code></pre></td></tr></table></figure><p>关闭</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo docker kill test<br><span class="hljs-meta prompt_">#</span><span class="language-bash">直接关闭容器</span><br></code></pre></td></tr></table></figure><p>暂停</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo docker pause test<br><span class="hljs-meta prompt_">#</span><span class="language-bash">暂停运行</span><br>sudo docker unpause test<br><span class="hljs-meta prompt_">#</span><span class="language-bash">恢复运行</span><br></code></pre></td></tr></table></figure><ul><li>stop，kill和pause的差别是，stop，kill让容器停止而pause则是让容器挂起</li></ul>]]></content>
    
    
    <categories>
      
      <category>服务器部署</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ubuntu</tag>
      
      <tag>docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>拓扑排序的简单介绍</title>
    <link href="/super_zhu/2022/11/08/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/"/>
    <url>/super_zhu/2022/11/08/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h1><h2 id="关于拓扑排序"><a href="#关于拓扑排序" class="headerlink" title="关于拓扑排序"></a>关于拓扑排序</h2><p>拓扑排序通俗点来说就是对于一个有向无环图(DAG)来说，不断输出其入度为0的节点直到不存在，每个节点输出一次且仅有一次</p><blockquote><p><strong>拓扑排序用官方的话来说就是</strong>：对一个有向无环图(DAG)G进行拓扑排序，是将G中所有顶点排成一个线性序列，使得图中任意一对顶点u和v，若边&lt;u,v&gt;∈E(G)，则u在线性序列中出现在v之前。通常，这样的线性序列称为满足拓扑次序(Topological Order)的序列，简称拓扑序列。简单的说，由某个集合上的一个偏序得到该集合上的一个全序，这个操作称之为拓扑排序。</p></blockquote><h2 id="执行步骤"><a href="#执行步骤" class="headerlink" title="执行步骤"></a>执行步骤</h2><p>拓扑排序主要步骤，也就主要循环两部分到不存在入度为零的顶点为止</p><ul><li>选择一个入度为零的顶点输出</li><li>在<code>AOV</code>网中删除这个顶点及其出边</li></ul><p>输出结束后，除非还有回路，否则其输出的顶点序列就是拓扑排序</p><blockquote><p>AOV网其实就是有向无回路图，就是DAG</p></blockquote><h3 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h3><p>对于以下图来说</p><p><img src="https://img-blog.csdnimg.cn/20210428200929462.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzUyMjkwNDM2,size_16,color_FFFFFF,t_70"></p><p>删除1和2顶点和其对于边后并且输出，并且以此类推</p><p><img src="https://img-blog.csdnimg.cn/20210428201000907.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzUyMjkwNDM2,size_16,color_FFFFFF,t_70"></p><p><img src="https://img-blog.csdnimg.cn/2021042820100737.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzUyMjkwNDM2,size_16,color_FFFFFF,t_70"></p><p><img src="https://img-blog.csdnimg.cn/20210428201017719.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzUyMjkwNDM2,size_16,color_FFFFFF,t_70"></p><p><img src="https://img-blog.csdnimg.cn/202104282010288.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzUyMjkwNDM2,size_16,color_FFFFFF,t_70" alt="·"></p><p>其实对于输出的序列不唯一就看你自己怎么样设计栈的结构</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>这里使用邻接表实现，再利用栈实现入度为零的输出</p><p>使用作业的题目，<code>ABCDEF</code>对应下标从0开始慢慢增大</p><p><img src="https://s2.loli.net/2022/11/08/zgsZPYbNG32c86F.jpg"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdbool.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXVEX 10</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">char</span> VerType;<span class="hljs-comment">//顶点值类型</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">EdgeNode</span>&#123;</span><br><span class="hljs-type">int</span> adjvex;<span class="hljs-comment">//邻接点域，存储该顶点对应的下标</span><br><span class="hljs-type">int</span> weight;<span class="hljs-comment">//用于存储权值，对于非网图可以不需要</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">EdgeNode</span>* <span class="hljs-title">next</span>;</span><span class="hljs-comment">//下一个结点</span><br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VertexNode</span>&#123;</span><br><span class="hljs-type">int</span> in;<span class="hljs-comment">//入度</span><br>VerType data;<span class="hljs-comment">//值</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">EdgeNode</span>* <span class="hljs-title">firstedge</span>;</span><span class="hljs-comment">//邻接表头指针</span><br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Graph</span>&#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VertexNode</span> <span class="hljs-title">vers</span>[<span class="hljs-title">MAXVEX</span>];</span><br><span class="hljs-type">int</span> numVertexes, numEdges;<span class="hljs-comment">//顶点数和边数</span><br>&#125;;<br><br><span class="hljs-comment">/* 拓扑排序，若G没有回路，则输出拓扑排序序列并返回OK，若有回路返回ERROR */</span><br><span class="hljs-type">int</span>  <span class="hljs-title function_">TopologicalSort</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> Graph* G)</span>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">EdgeNode</span>* <span class="hljs-title">e</span>;</span><br><span class="hljs-type">int</span> i, k, gettop;<br><span class="hljs-type">int</span> top = <span class="hljs-number">0</span>;<span class="hljs-comment">//栈指针下标</span><br><span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<span class="hljs-comment">//统计输出顶点个数</span><br><span class="hljs-type">int</span>* <span class="hljs-built_in">stack</span>;<span class="hljs-comment">//存储入度为0的顶点</span><br><span class="hljs-built_in">stack</span> = (<span class="hljs-type">int</span>*)<span class="hljs-built_in">malloc</span>(G-&gt;numVertexes * <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>));<br><br><span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>;i&lt;G-&gt;numVertexes;i++)<span class="hljs-comment">//遍历所有结点</span><br><span class="hljs-keyword">if</span>(G-&gt;vers[i].in == <span class="hljs-number">0</span>)<br><span class="hljs-built_in">stack</span>[++top] = i;<span class="hljs-comment">//将入度为0的顶点入栈</span><br><br><span class="hljs-keyword">while</span>(top != <span class="hljs-number">0</span>)&#123;<br>gettop = <span class="hljs-built_in">stack</span>[top--];<span class="hljs-comment">//出栈</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c &quot;</span>,G-&gt;vers[gettop].data);<br>count++;<span class="hljs-comment">//统计输出顶点数</span><br><span class="hljs-keyword">for</span>(e=G-&gt;vers[gettop].firstedge; e; e = e-&gt;next)&#123;<br><span class="hljs-comment">//弧表遍历</span><br>k = e-&gt;adjvex;<br><span class="hljs-keyword">if</span>(!(--G-&gt;vers[k].in))<span class="hljs-comment">//将k号顶点邻接点的入度减1</span><br><span class="hljs-built_in">stack</span>[++top] = k;<span class="hljs-comment">//若为0则入栈，以便下次循环输出</span><br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span>(count &lt; G-&gt;numVertexes)<span class="hljs-comment">//如果count小于顶点数，说明存在环</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">else</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-comment">/* 图初始化 */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">CreateGraph</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> Graph* G)</span>&#123;<br><span class="hljs-type">int</span> i, m, n;<br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;输入顶点数和边数：\n&quot;</span>);<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>,&amp;G-&gt;numVertexes, &amp;G-&gt;numEdges);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;输入顶点值：\n&quot;</span>);<br>    getchar();<span class="hljs-comment">//吃掉回车</span><br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;G-&gt;numVertexes;i++)&#123;<br><span class="hljs-comment">//getchar();//吃掉回车</span><br>G-&gt;vers[i].data=getchar();<br>getchar();<br><span class="hljs-comment">//scanf(&quot;%c&quot;,&amp;G-&gt;vers[i].data);</span><br>&#125;<br><span class="hljs-comment">//初始化图头结点指针和入度值</span><br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;G-&gt;numVertexes;i++)&#123;<br>G-&gt;vers[i].firstedge = <span class="hljs-literal">NULL</span>;<br>G-&gt;vers[i].in = <span class="hljs-number">0</span>;<span class="hljs-comment">//入度为0</span><br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;输入边：\n&quot;</span>);<br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;G-&gt;numEdges;i++)&#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>,&amp;m, &amp;n);<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">EdgeNode</span> *<span class="hljs-title">newNode</span> =</span> (<span class="hljs-keyword">struct</span> EdgeNode*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> EdgeNode));<br>newNode-&gt;next = G-&gt;vers[m].firstedge == <span class="hljs-literal">NULL</span> ? <span class="hljs-literal">NULL</span> : G-&gt;vers[m].firstedge;<br>newNode-&gt;adjvex = n;<br>G-&gt;vers[m].firstedge = newNode;<br>G-&gt;vers[n].in++;<span class="hljs-comment">//入度+1</span><br>&#125;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Graph</span> *<span class="hljs-title">G</span>=</span>(<span class="hljs-keyword">struct</span> Graph*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> Graph)) ;<br>CreateGraph(G);<br><span class="hljs-keyword">if</span>(TopologicalSort(G))&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;拓扑排序完成！\n&quot;</span>);<br>&#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;图存在环&quot;</span>);<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>图的两种存储结构</title>
    <link href="/super_zhu/2022/11/07/%E5%9B%BE%E7%9A%84%E4%B8%A4%E7%A7%8D%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/"/>
    <url>/super_zhu/2022/11/07/%E5%9B%BE%E7%9A%84%E4%B8%A4%E7%A7%8D%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<h1 id="图的两种存储结构"><a href="#图的两种存储结构" class="headerlink" title="图的两种存储结构"></a>图的两种存储结构</h1><h2 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h2><p><strong>图的邻接矩阵(Adjacency Matrix) 存储方式是用两个数组来表示图。一个一维数组存储图中顶点信息，一个二维数组(称为邻接矩阵)存储图中的边或弧的信息。</strong></p><ul><li><p>即有一个数组存储顶点</p></li><li><p>一个维数组存储各个顶点之间的关系，即是存储边的信息，比如权值</p></li><li><p>有向图和无向图的的矩阵存储不一样</p></li></ul><p>比如下图，假如有一个是有n个顶点的图，则邻接矩阵是一个n*n的方阵，以下定义</p><p><img src="https://s2.loli.net/2022/11/08/v89P2IeYEnOmZpr.png">)</p><h3 id="无向图和他的邻接矩阵"><a href="#无向图和他的邻接矩阵" class="headerlink" title="无向图和他的邻接矩阵"></a>无向图和他的邻接矩阵</h3><p><img src="https://s2.loli.net/2022/11/08/PnXkO6RavKJCDIT.png"></p><ul><li>比如v1的顶点入度为1+1&#x3D;2</li><li>求顶点v i 的所有邻接点就是将矩阵中第i行元素扫描一遍， A [ i ] [ j ] &#x3D; 1就是邻接点</li><li>看vi是否和vj相连接，直接看是否A[i] [j]&#x3D;1或者A[j] [i]&#x3D;1都可以</li></ul><h3 id="有向图和它的邻接矩阵"><a href="#有向图和它的邻接矩阵" class="headerlink" title="有向图和它的邻接矩阵"></a>有向图和它的邻接矩阵</h3><p>有向图的矩阵并不是对称矩阵，看下图</p><p><img src="https://s2.loli.net/2022/11/08/yiD76uFmIAQkpeb.png"></p><ul><li>因为是有向图，所以入度和出度并不相同，比如v1的出度看数组的第一行不为一的数目，而入度则是看第一列不为一的数目，所以入度为1而出度为2</li><li>判断顶点v i到v j  是否存在弧，只需要查找矩阵中A [ i ] [ j ]是否为1即可</li></ul><h3 id="对于带权值的有向图"><a href="#对于带权值的有向图" class="headerlink" title="对于带权值的有向图"></a>对于带权值的有向图</h3><p>vi和vj之间有链接的话，则相应的A[i] [j]&#x3D;权值，即看下图</p><p><img src="https://s2.loli.net/2022/11/08/c7Pf5DkXNQyIR13.png"></p><ul><li><p>相连的话，相对应的A[i] [j]则用权值表示</p></li><li><p>如果不相连则用<br>$$<br>\infty<br>$$</p></li></ul><p>表示以下是一个图的简单定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MaxVertexNum 100<span class="hljs-comment">//顶点数目的最大值</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">char</span> VertexType;<span class="hljs-comment">//顶点的数据类型</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> EdgeType;<span class="hljs-comment">//带权图中边上权值的数据类型</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br>VertexType Vex[MaxVertexNum];<span class="hljs-comment">//顶点表</span><br>EdgeType Edge[MaxVertexNum][MaxVertexNum];<span class="hljs-comment">//邻接矩阵，边表</span><br><span class="hljs-type">int</span> vexnum, arcnum;<span class="hljs-comment">//图的当前顶点数和边数</span><br>&#125;MGraph;<br><br></code></pre></td></tr></table></figure><h2 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h2><p>当一个图的边数太少用邻接矩阵的方式存储，太浪费空间，如下</p><p><img src="https://s2.loli.net/2022/11/08/kpWIRwFxfZGVOsq.png"></p><ul><li><p>邻接表对于每一个顶点vi都建立了一个单链表，链表每个节点都存储着与vi相连的顶点信息，比如v1的单链表中有一个节点存储着v2的信息，则代表v1—–&gt;v2(当为无向图时表示v1————v2)</p></li><li><p>所以邻接表共有两种表结构 </p><ol><li>一个是顶点表存储顶点信息，同时存储着指向相应链表的指针，</li><li>一个是边表存储边的信息，存储被指向的节点和权值</li></ol></li></ul><p>如下图</p><p><img src="https://s2.loli.net/2022/11/08/BAS98Xcmj6E1NUk.png"></p><p>对于无向图的实例如下</p><p><img src="https://s2.loli.net/2022/11/08/zCBDghNbaWlo6jG.png"></p><p>对于有向图的实例如下</p><p><img src="https://s2.loli.net/2022/11/08/5FZKvoYk7TngyI4.png"></p><p>而代码实例如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXVEX 100<span class="hljs-comment">//图中顶点数目的最大值</span></span><br>type <span class="hljs-type">char</span> VertexType;<span class="hljs-comment">//顶点类型应由用户定义</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> EdgeType;<span class="hljs-comment">//边上的权值类型应由用户定义</span><br><span class="hljs-comment">/*边表结点*/</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">EdgeNode</span>&#123;</span><br><span class="hljs-type">int</span> adjvex;<span class="hljs-comment">//该弧所指向的顶点的下标或者位置</span><br>EdgeType weight;<span class="hljs-comment">//权值，对于非网图可以不需要</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">EdgeNode</span> *<span class="hljs-title">next</span>;</span><span class="hljs-comment">//指向下一个邻接点</span><br>&#125;EdgeNode;<br><br><span class="hljs-comment">/*顶点表结点*/</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VertexNode</span>&#123;</span><br>Vertex data;<span class="hljs-comment">//顶点域，存储顶点信息</span><br>EdgeNode *firstedge<span class="hljs-comment">//边表头指针</span><br>&#125;VertexNode, AdjList[MAXVEX];<br><br><span class="hljs-comment">/*邻接表*/</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br>AdjList adjList;<br><span class="hljs-type">int</span> numVertexes, numEdges;<span class="hljs-comment">//图中当前顶点数和边数</span><br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>这里对于图的存储结构只做简单的介绍</strong>，<strong>如果要了解更多性质自行查找</strong></p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ubuntu部署-换源</title>
    <link href="/super_zhu/2022/11/02/ubantu%E9%83%A8%E7%BD%B2-%E6%8D%A2%E6%BA%90/"/>
    <url>/super_zhu/2022/11/02/ubantu%E9%83%A8%E7%BD%B2-%E6%8D%A2%E6%BA%90/</url>
    
    <content type="html"><![CDATA[<h1 id="源是什么"><a href="#源是什么" class="headerlink" title="源是什么"></a>源是什么</h1><p>源对于<code>ubuntu</code>通俗点来说就是一个软件库，下载软件时只需要记得相应软件名，通过包管理工具apt可一键下载，比如下载<code>gcc</code>  只需要<code>sudo apt install gcc</code> 即可。</p><p><em>apt具体相关可前往<a href="https://www.runoob.com/linux/linux-comm-apt.html%E4%BA%86%E8%A7%A3">https://www.runoob.com/linux/linux-comm-apt.html了解</a></em></p><h1 id="为什么要换源"><a href="#为什么要换源" class="headerlink" title="为什么要换源"></a>为什么要换源</h1><p><code>Ubuntu</code>的源服务器是在外国，所以在我们平常下载软件的时候，下载速度是很慢的，甚至可能断掉，所以会使用国内的镜像，科大，阿里，网易，清华的源速度飞快，不但节省生命，还可以降低心脏病发病概率。</p><blockquote><p>镜像通常用于为相同信息内容提供不同的源，特别是在下载量大的时候提供了一种可靠的网络连接。制作镜像是一种文件同步的过程。“镜像网站”（英文:Mirror sites [1] ），又译作““镜像站点” ，亦即把一个互联网上的网站数据“拷贝”到本地服务器，并保持本地服务器数据的同步更新，因此也称为“复制网络站点” 。</p><hr><p>镜像源就是把官方的源做一个镜像，你可以在这下载软件。<br>比如<code>ubuntu</code>官方源在国外，下载软件可能会很慢，这时候就需要换成国内的镜像源。</p></blockquote><h1 id="换源过程"><a href="#换源过程" class="headerlink" title="换源过程"></a>换源过程</h1><p>我以Ubuntu18.04为例</p><h2 id="源在哪里"><a href="#源在哪里" class="headerlink" title="源在哪里"></a>源在哪里</h2><p>源一般在系统的<code>/etc/apt/sources.list</code>中，在命令行输入<code>vim sources.list</code>即可查看</p><h2 id="开始换源"><a href="#开始换源" class="headerlink" title="开始换源"></a>开始换源</h2><p>首先我们要寻找合适的国内源，一般有阿里源，清华源，中科院源，这里我以阿里为例</p><p>点击<a href="https://developer.aliyun.com/mirror/ubuntu">ubuntu镜像_ubuntu下载地址_ubuntu安装教程-阿里巴巴开源镜像站 (aliyun.com)</a>，进入后根据自己系统版本选择合适的源</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs awk">deb https:<span class="hljs-regexp">//mi</span>rrors.aliyun.com<span class="hljs-regexp">/ubuntu/</span> bionic main restricted universe multiverse<br>deb-src https:<span class="hljs-regexp">//mi</span>rrors.aliyun.com<span class="hljs-regexp">/ubuntu/</span> bionic main restricted universe multiverse<br><br>deb https:<span class="hljs-regexp">//mi</span>rrors.aliyun.com<span class="hljs-regexp">/ubuntu/</span> bionic-security main restricted universe multiverse<br>deb-src https:<span class="hljs-regexp">//mi</span>rrors.aliyun.com<span class="hljs-regexp">/ubuntu/</span> bionic-security main restricted universe multiverse<br><br>deb https:<span class="hljs-regexp">//mi</span>rrors.aliyun.com<span class="hljs-regexp">/ubuntu/</span> bionic-updates main restricted universe multiverse<br>deb-src https:<span class="hljs-regexp">//mi</span>rrors.aliyun.com<span class="hljs-regexp">/ubuntu/</span> bionic-updates main restricted universe multiverse<br><br><span class="hljs-comment"># deb https://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse</span><br><span class="hljs-comment"># deb-src https://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse</span><br><br>deb https:<span class="hljs-regexp">//mi</span>rrors.aliyun.com<span class="hljs-regexp">/ubuntu/</span> bionic-backports main restricted universe multiverse<br>deb-src https:<span class="hljs-regexp">//mi</span>rrors.aliyun.com<span class="hljs-regexp">/ubuntu/</span> bionic-backports main restricted universe multiverse<br><br></code></pre></td></tr></table></figure><p>如下是Ubuntu 18.04的中科院的源<a href="https://mirrors.ustc.edu.cn/repogen/">https://mirrors.ustc.edu.cn/repogen/</a></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs awk">deb https:<span class="hljs-regexp">//mi</span>rrors.ustc.edu.cn<span class="hljs-regexp">/ubuntu/</span> bionic main restricted universe multiverse<br>deb-src https:<span class="hljs-regexp">//mi</span>rrors.ustc.edu.cn<span class="hljs-regexp">/ubuntu/</span> bionic main restricted universe multiverse<br><br>deb https:<span class="hljs-regexp">//mi</span>rrors.ustc.edu.cn<span class="hljs-regexp">/ubuntu/</span> bionic-security main restricted universe multiverse<br>deb-src https:<span class="hljs-regexp">//mi</span>rrors.ustc.edu.cn<span class="hljs-regexp">/ubuntu/</span> bionic-security main restricted universe multiverse<br><br>deb https:<span class="hljs-regexp">//mi</span>rrors.ustc.edu.cn<span class="hljs-regexp">/ubuntu/</span> bionic-updates main restricted universe multiverse<br>deb-src https:<span class="hljs-regexp">//mi</span>rrors.ustc.edu.cn<span class="hljs-regexp">/ubuntu/</span> bionic-updates main restricted universe multiverse<br><br>deb https:<span class="hljs-regexp">//mi</span>rrors.ustc.edu.cn<span class="hljs-regexp">/ubuntu/</span> bionic-backports main restricted universe multiverse<br>deb-src https:<span class="hljs-regexp">//mi</span>rrors.ustc.edu.cn<span class="hljs-regexp">/ubuntu/</span> bionic-backports main restricted universe multiverse<br></code></pre></td></tr></table></figure><p>然后，来到系统下的&#x2F;etc&#x2F;apt，输入命令vim sources.list打开文件，删除原来的，粘贴上去</p><p>输入<code>:wq</code>，点击enter键推出，再输入</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">sudo apt-<span class="hljs-built_in">get</span> update<br>sudo apt-<span class="hljs-built_in">get</span> upgrade<br></code></pre></td></tr></table></figure><p>遇到问题只需要一直y即可</p><p>换源完成</p>]]></content>
    
    
    <categories>
      
      <category>服务器部署</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ubuntu</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ubuntu部署-mysql</title>
    <link href="/super_zhu/2022/11/02/ubuntu%E9%83%A8%E7%BD%B2-mysql/"/>
    <url>/super_zhu/2022/11/02/ubuntu%E9%83%A8%E7%BD%B2-mysql/</url>
    
    <content type="html"><![CDATA[<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>在下载中，如遇到源的问题，请跳转到换源篇章</p><p>需要了解更多或者更为细致，请前往MySQL官网<a href="https://dev.mysql.com/">软件开发模块 ：： 开发者专区 (mysql.com)</a></p><h1 id="开始配置"><a href="#开始配置" class="headerlink" title="开始配置"></a>开始配置</h1><h2 id="下载mysql"><a href="#下载mysql" class="headerlink" title="下载mysql"></a>下载mysql</h2><p>在命令行输入，以下命令，遇到问题输入y即可</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs axapta">sudo apt install mysql-<span class="hljs-keyword">server</span><br></code></pre></td></tr></table></figure><p>下载好后，默认有一个没有密码的超级账号，输入以下代码即可进入mysql命令行</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">sudo mysql</span><br></code></pre></td></tr></table></figure><h2 id="配置用户"><a href="#配置用户" class="headerlink" title="配置用户"></a>配置用户</h2><h3 id="查看用户表"><a href="#查看用户表" class="headerlink" title="查看用户表"></a>查看用户表</h3><p>mysql的用户信息是存储在mysql库的user表里的，执行以下命令,查看用户的信息</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs n1ql">use mysql;<br><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span>;<br></code></pre></td></tr></table></figure><h3 id="创建用户"><a href="#创建用户" class="headerlink" title="创建用户"></a>创建用户</h3><p>使用以下命令，可创建用户</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">USER</span> <span class="hljs-string">&#x27;用户名&#x27;</span>@<span class="hljs-string">&#x27;IP地址或者域名&#x27;</span>  IDENTIFIED <span class="hljs-keyword">BY</span> <span class="hljs-string">&#x27;*password*&#x27;</span>;<br></code></pre></td></tr></table></figure><p>其中<strong>ip地址或者域名</strong>那里，如果使用通配符**%**代替，则代表可以在任何电脑使用你这个账号进行登录</p><h3 id="查看用户权限"><a href="#查看用户权限" class="headerlink" title="查看用户权限"></a>查看用户权限</h3><p>刚刚创建的用户是没有操作表权限的</p><p>在命令行输入</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">SHOW</span> GRANTS FOR <span class="hljs-string">&#x27;用户名&#x27;</span>@<span class="hljs-string">&#x27;ip地址&#x27;</span>;<br></code></pre></td></tr></table></figure><h3 id="授予用户权限"><a href="#授予用户权限" class="headerlink" title="授予用户权限"></a>授予用户权限</h3><p>授予用户的万能公式是</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">grant</span> <span class="hljs-string">&#x27;权限列表&#x27;</span>  <span class="hljs-keyword">on</span> <span class="hljs-string">&#x27;数据库名.表名&#x27;</span> <span class="hljs-keyword">to</span>  <span class="hljs-string">&#x27;用户名&#x27;</span>@<span class="hljs-string">&#x27;主机名&#x27;</span>&lt;<span class="hljs-keyword">WITH</span> <span class="hljs-keyword">GRANT</span> <span class="hljs-keyword">OPTION</span>&gt;<br></code></pre></td></tr></table></figure><p>其中<code>WITH GRANT OPTION</code>是代表赋予这个用户赋予其他用户的权限，可加可不加</p><p>要是要，赋予这个用户全部权限，可执行以下命令</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">GRANT</span> <span class="hljs-keyword">ALL</span>  <span class="hljs-keyword">ON</span> *.*  <span class="hljs-keyword">TO</span> <span class="hljs-string">&#x27;用户名&#x27;</span>@<span class="hljs-string">&#x27;主机IP地址&#x27;</span>  <span class="hljs-keyword">WITH</span> <span class="hljs-keyword">GRANT</span> <span class="hljs-keyword">OPTION</span>;<br></code></pre></td></tr></table></figure><p>其中<code>All</code>代表赋予<strong>出除了授予他人特权之外的全部权限</strong>，其中<code>*.*</code>代表可以操作所有的库中的所有表</p><h3 id="修改用户密码"><a href="#修改用户密码" class="headerlink" title="修改用户密码"></a>修改用户密码</h3><p>使用以下命令，即可</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">alter</span> <span class="hljs-keyword">user</span> <span class="hljs-string">&#x27;用户名&#x27;</span>@<span class="hljs-string">&#x27;主机名&#x27;</span> identified  <span class="hljs-keyword">with</span> caching_sha2_password  <span class="hljs-keyword">by</span> <span class="hljs-string">&#x27;新密码&#x27;</span><br></code></pre></td></tr></table></figure><p>其中<code>caching_sha2_password</code>代表登录时身份验证是使用caching_sha2_password插件进行验证</p><h2 id="超级重要的！！！"><a href="#超级重要的！！！" class="headerlink" title="超级重要的！！！"></a>超级重要的！！！</h2><p><strong>这个对于想要远程连接时是必须的！！！</strong></p><p><strong>因为Ubuntu的mysql默认是不允许其他主机连接，所以必须修改相应配置！！！</strong></p><p><strong>本人表示非常难受（因为本来不知道）</strong></p><p>配置文件是<code>/etc/mysql/mysql.conf.d/mysqld.cnf</code>输入命令行</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">sudo vim <span class="hljs-regexp">/etc/my</span>sql<span class="hljs-regexp">/mysql.conf.d/my</span>sqld.cnf<br></code></pre></td></tr></table></figure><p>将其中的<code>bind-address=127.0.0.1</code>修改成<code>bind-address=0.0.0.0</code></p><p>然后再<code>:wq</code>保存退出</p><p>再输入命令重启mysql</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">sudo service mysql restart</span><br></code></pre></td></tr></table></figure><h1 id="mysql的校验规则"><a href="#mysql的校验规则" class="headerlink" title="mysql的校验规则"></a>mysql的校验规则</h1><p>mysql 5.7后如果程序中的sql语句使用了group by等，可能会报1055的错，其原因是mysql5.7 版本中有了一个select mode（严格模式）</p><h2 id="临时办法（重启mysql后失效）"><a href="#临时办法（重启mysql后失效）" class="headerlink" title="临时办法（重启mysql后失效）"></a>临时办法（重启mysql后失效）</h2><p>打开mysql命令行执行</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SET</span> <span class="hljs-keyword">GLOBAL</span> sql_mode<span class="hljs-operator">=</span>(<span class="hljs-keyword">SELECT</span> REPLACE(@<span class="hljs-variable">@sql</span>_mode,<span class="hljs-string">&#x27;ONLY_FULL_GROUP_BY&#x27;</span>,<span class="hljs-string">&#x27;&#x27;</span>));<br></code></pre></td></tr></table></figure><p>但要在拥有root权限下</p><p>其中原因sql_mode是一组语法校验规则</p><h2 id="永久办法"><a href="#永久办法" class="headerlink" title="永久办法"></a>永久办法</h2><p>打开<code>/etc/mysql/mysql.conf.d/mysqld.cnf</code>文件</p><p>在其<code>[mysqld]</code>下添加</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"># 设置sql_mode,关闭ONLY_FULL_GROUP_BY,避免使用<span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span>函数导致<span class="hljs-number">1055</span>错误<br>sql_mode<span class="hljs-operator">=</span>STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION<br><br></code></pre></td></tr></table></figure><p>然后再进行重启mysql</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo service mysql restart<br></code></pre></td></tr></table></figure><p>完成</p>]]></content>
    
    
    <categories>
      
      <category>服务器部署</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ubuntu</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ubuntu部署-nginx</title>
    <link href="/super_zhu/2022/11/01/ubuntu%E9%83%A8%E7%BD%B2-nginx/"/>
    <url>/super_zhu/2022/11/01/ubuntu%E9%83%A8%E7%BD%B2-nginx/</url>
    
    <content type="html"><![CDATA[<h1 id="配置https"><a href="#配置https" class="headerlink" title="配置https"></a>配置https</h1><p>需编辑<code>/etc/nginx/nginx.conf</code>或者<code>/etc/nginx/sites-enabled/default</code></p><p>请按照以下格式配置</p><p>若是想要nginx更为详细的配置，请前往<a href="https://blog.csdn.net/aiwangtingyun/article/details/118823582">(151条消息) 【Nginx】之 nginx.conf 配置详解_王廷云的博客的博客-CSDN博客_nginxconf配置</a></p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs applescript">server&#123;<br>listen <span class="hljs-number">443</span> ssl; <br>     <span class="hljs-comment">#请填写绑定证书的域名</span><br>     server_name qiuwo.xyz; <br>     <span class="hljs-comment">#请填写证书文件的相对路径或绝对路径</span><br>     ssl_certificate qiuwo.xyz_bundle.crt; <span class="hljs-comment">#这里是相对路径</span><br>     <span class="hljs-comment">#请填写私钥文件的相对路径或绝对路径</span><br>     ssl_certificate_key qiuwo.xyz.key;<span class="hljs-comment">#这里是相对路径</span><br>     ssl_session_timeout <span class="hljs-number">5</span>m;<br>     <span class="hljs-comment">#请按照以下协议配置</span><br>     ssl_protocols TLSv1<span class="hljs-number">.2</span> TLSv1<span class="hljs-number">.3</span>; <br>     <span class="hljs-comment">#请按照以下套件配置，配置加密套件，写法遵循 openssl 标准。</span><br>     ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE; <br>     ssl_prefer_server_ciphers <span class="hljs-keyword">on</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="反向代理请求"><a href="#反向代理请求" class="headerlink" title="反向代理请求"></a>反向代理请求</h1><h2 id="proxy-pass"><a href="#proxy-pass" class="headerlink" title="proxy_pass"></a>proxy_pass</h2><p>反向代理请求，我一般使用proxy_pass进行代理，如下</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs crmsh"><span class="hljs-keyword">location</span> <span class="hljs-title">/wx_post</span> &#123;<br>proxy_pass http://<span class="hljs-number">124.221</span>.<span class="hljs-number">80.208</span>:<span class="hljs-number">8083</span><br>&#125;<br></code></pre></td></tr></table></figure><p> 当我对服务器发起<a href="https://qiuwo.xyz/wx_post/xxx%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8Cnginx%E4%BC%9A%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E5%88%B0http://124.221.80.208:8083/wx_post/xxx">https://qiuwo.xyz/wx_post/xxx的时候，nginx会反向代理到http://124.221.80.208:8083/wx_post/xxx</a></p><h2 id="“-x2F-“有无的区别"><a href="#“-x2F-“有无的区别" class="headerlink" title="“&#x2F;“有无的区别"></a>“&#x2F;“有无的区别</h2><p>现在我请求的地址为<a href="https://qiuwo.xyz/wx_post/xxx">https://qiuwo.xyz/wx_post/xxx</a></p><p>有以下请求情况</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs awk">location /wx_post &#123;<br>proxy_pass http:<span class="hljs-regexp">//</span><span class="hljs-number">124.221</span>.<span class="hljs-number">80.208</span>:<span class="hljs-number">8083</span>           --A<br>&#125;<br><br><br>location /wx_post &#123;<br>proxy_pass http:<span class="hljs-regexp">//</span><span class="hljs-number">124.221</span>.<span class="hljs-number">80.208</span>:<span class="hljs-number">8083</span>/          --B<br>&#125;<br><br><br>location <span class="hljs-regexp">/wx_post/</span> &#123;<br>proxy_pass http:<span class="hljs-regexp">//</span><span class="hljs-number">124.221</span>.<span class="hljs-number">80.208</span>:<span class="hljs-number">8083</span>/         --C<br>&#125;<br><br><br>location <span class="hljs-regexp">/wx_post/</span> &#123;<br>proxy_pass http:<span class="hljs-regexp">//</span><span class="hljs-number">124.221</span>.<span class="hljs-number">80.208</span>:<span class="hljs-number">8083</span>           --D<br>&#125;<br></code></pre></td></tr></table></figure><p>对应的请求结果为</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk">http:<span class="hljs-regexp">//</span><span class="hljs-number">124.221</span>.<span class="hljs-number">80.208</span>:<span class="hljs-number">8083</span><span class="hljs-regexp">/wx_post/</span>xxx  --A<br>http:<span class="hljs-regexp">//</span><span class="hljs-number">124.221</span>.<span class="hljs-number">80.208</span>:<span class="hljs-number">8083</span><span class="hljs-regexp">//</span>xxx   --B<br>http:<span class="hljs-regexp">//</span><span class="hljs-number">124.221</span>.<span class="hljs-number">80.208</span>:<span class="hljs-number">8083</span>/xxx    --C<br>http:<span class="hljs-regexp">//</span><span class="hljs-number">124.221</span>.<span class="hljs-number">80.208</span>:<span class="hljs-number">8083</span><span class="hljs-regexp">/wx_post/</span>xxx   --D<br></code></pre></td></tr></table></figure><p>在对于端口后面还有路径也是一样的情况，比如配置为</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs awk">location /wx_post &#123;<br>proxy_pass http:<span class="hljs-regexp">//</span><span class="hljs-number">124.221</span>.<span class="hljs-number">80.208</span>:<span class="hljs-number">8083</span>/hhh<br>&#125;<br>location <span class="hljs-regexp">/wx_post/</span> &#123;<br>proxy_pass http:<span class="hljs-regexp">//</span><span class="hljs-number">124.221</span>.<span class="hljs-number">80.208</span>:<span class="hljs-number">8083</span>/hhh<br>&#125;<br></code></pre></td></tr></table></figure><p>则反向代理为<a href="http://124.221.80.208:8083/hhh/xxx%E5%92%8Chttp://124.221.80.208:8083/hhhxxx">http://124.221.80.208:8083/hhh/xxx和http://124.221.80.208:8083/hhhxxx</a></p><h2 id="配置静态资源"><a href="#配置静态资源" class="headerlink" title="配置静态资源"></a>配置静态资源</h2><p>配置静态资源有两种方式root和alias</p><p>假如你文件路径为&#x2F;home&#x2F;ubuntu&#x2F;post&#x2F;images&#x2F;xxx.jpg</p><p>​      请求地址为<a href="https://qiuwo.xyz/xxx">https://qiuwo.xyz/xxx</a></p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs crmsh"><span class="hljs-comment"># 请求地址为https://qiuwo.xyz/ubuntu/post/images/xxx.png</span><br><span class="hljs-keyword">location</span> <span class="hljs-title">/ubuntu</span> &#123;   <br>    root /home<br>&#125;<br><br><span class="hljs-comment">#请求地址 https://qiuwo.xyz/hhh/post/images/xxx.png</span><br><span class="hljs-keyword">location</span> <span class="hljs-title">/hhh</span> &#123;<br>    alias /home/ubuntu  <span class="hljs-comment">#如果你在Ubuntu后面加上斜杠&quot;/&quot;那么home后面也要</span><br>&#125;<br></code></pre></td></tr></table></figure><p>以上是情况实例</p>]]></content>
    
    
    <categories>
      
      <category>服务器部署</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ubuntu</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2022年绘蓝杯-小程序赛题</title>
    <link href="/super_zhu/2022/10/31/2022%E5%B9%B4%E7%BB%98%E8%93%9D%E6%9D%AF%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8FB%E7%BB%84%E8%B5%9B%E9%A2%98/"/>
    <url>/super_zhu/2022/10/31/2022%E5%B9%B4%E7%BB%98%E8%93%9D%E6%9D%AF%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8FB%E7%BB%84%E8%B5%9B%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="2022年绘蓝杯微信小程序B组赛题"><a href="#2022年绘蓝杯微信小程序B组赛题" class="headerlink" title="2022年绘蓝杯微信小程序B组赛题"></a>2022年绘蓝杯微信小程序B组赛题</h1><p><strong>主题不限（需体现一定的代码量，逻辑量）</strong></p><h2 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h2><h3 id="1-视觉要求"><a href="#1-视觉要求" class="headerlink" title="1.视觉要求"></a>1.视觉要求</h3><p>（1）界面优美，元素排列整齐合理</p><p>（2）至少包含三个tabbar页面和两个子页面</p><h3 id="2-功能要求"><a href="#2-功能要求" class="headerlink" title="2.功能要求"></a>2.功能要求</h3><p>（1）实现页面的跳转</p><p>（2）使用自定义组件</p><p>（2）运用有一定的JavaScript知识（看熟练程度加分）</p><p>（3）使用api（原生或者第三方）实现相应功能（加分项）</p><p>（3）可以简单使用云开发数据库（加分项）</p><h3 id="3-推荐相关资料"><a href="#3-推荐相关资料" class="headerlink" title="3.推荐相关资料"></a>3.推荐相关资料</h3><p>（<strong>云开发&amp;小程序原生api官方文档）</strong><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/">微信开放文档 (qq.com)</a></p><p><strong>（推荐云开发学习视频）</strong><a href="https://www.bilibili.com/video/BV12z4y1R77r/?spm_id_from=333.337.search-card.all.click">微信小程序云开发基础到实战 云数据库 云函数 云存储 云调用【新视觉】_哔哩哔哩_bilibili</a></p><p> <strong>（第三方api接口）</strong></p><p>  <a href="https://market.aliyun.com/data">API_API接口平台_API数据【最新】_API接口大全_API认证 - 阿里云 (aliyun.com)</a></p><p> <a href="https://wx.jdcloud.com/api/0_0/1">  API-免费API数据接口平台-京东万象 (jdcloud.com)</a></p><p><strong>也可以自行查找相关资料，以上只是推荐</strong></p>]]></content>
    
    
    <categories>
      
      <category>科协事务</category>
      
    </categories>
    
    
    <tags>
      
      <tag>绘蓝杯</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
